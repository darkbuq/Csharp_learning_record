# Two's Complement 二補數法

因為不是資工背景 所以每次看都是看懂 過眼即忘  
沒有一個 深刻的邏輯 吃透到 腦神經的鏈結上  

>正數的二補數 => 十進制轉二進制  
>負數的二補數 => 取反(即一補數) => 加一

所以我在找一個足夠直覺的理解路線 讓 `二的補數` 達到接近心算的程度

---
```csharp
public string short_to_HexStr_by_2sComplement(short intt)
{
    if (intt >= 0)
    {
        return intt.ToString("X4");
    }
    else
    {
        return (65536 + intt).ToString("X4");
    }
}
```
### 以下是我找到 對我來說 最有感覺的排序 來應付上面程式碼的理解
--- 
| Dec | Binary | Two's Complement |
|-----|--------|------------------|
| 0   | 0000   | 0                |
| 1   | 0001   | 1                |
| 2   | 0010   | 2                |
| 3   | 0011   | 3                |
| 4   | 0100   | 4                |
| 5   | 0101   | 5                |
| 6   | 0110   | 6                |
| 7   | 0111   | 7                |
| 8   | 1000   | -8               |
| 9   | 1001   | -7               |
| 10  | 1010   | -6               |
| 11  | 1011   | -5               |
| 12  | 1100   | -4               |
| 13  | 1101   | -3               |
| 14  | 1110   | -2               |
| 15  | 1111   | -1               |
| 16  | 10000  | 溢位一格          |


---
### 以4個bit 來說明  

從0~7  基本上就是 十進制 轉換成 二進制

如果是 `負數` 的轉換  就需要 溢位1格 (10000) 再倒數回來
例如： -2的二補數： 溢位10000=>1111=>1110

---

