# Task.Run(...)

>如果 任務是兼著做兩件事  
>一個主線   一個支線  支線實際要跑要算很久才會跑完  
>就不太適合  非同步了吧  
>非同步   適合兩件事  都有   一些地方沒事做在等待   
>  
>以上看法對嗎 

---
要讓「真的在跑的計算密集支線」不卡住主線，你應該使用：

```csharp
await Task.Run(() => LongRunningWork());
```
這才是「讓重計算的任務跑在背景執行緒上」的正確方法。

---
我們來做一個**完整範例**，展示「**主線做印字工作，支線做耗時計算，但兩者不互相卡住**」。


### ✅ 示範情境：

* 主線任務：每秒顯示一次時間（模擬 UI 或其他邏輯）
* 支線任務：做一個大量計算（跑 `for` 迴圈算平方根）
* 支線用 `Task.Run(...)` 跑在背景執行緒，不會卡住主線

---

### ✅ 完整程式碼如下：

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    class Program
    {
        static async Task Main(string[] args)
        {
            // 啟動支線計算（跑在背景執行緒）
            var longRunningTask = Task.Run(() => HeavyCalculation());

            // 主線任務持續做自己的事（印出時間）
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine($"主線工作中... {i} - {DateTime.Now}");
                await Task.Delay(1000); // 模擬主線每秒執行一次工作
            }

            // 等支線任務做完
            await longRunningTask;
            Console.WriteLine("支線計算完成！");
            Console.ReadLine();
        }

        public static void HeavyCalculation()
        {
            Console.WriteLine("支線開始大量計算...");
            double result = 0;
            for (int i = 0; i < 20; i++)
            {
                Console.WriteLine($"     支線工作中... {i} - {DateTime.Now}");
                Thread.Sleep(500);
            }
            Console.WriteLine("支線完成計算！");
        }
    }
}
```

---

### 🧠 執行時會看到這種順序：

```
支線開始大量計算...
     支線工作中... 0 - 2025/7/16 下午 12:25:57
主線工作中... 0 - 2025/7/16 下午 12:25:57
     支線工作中... 1 - 2025/7/16 下午 12:25:57
     支線工作中... 2 - 2025/7/16 下午 12:25:58
主線工作中... 1 - 2025/7/16 下午 12:25:58
     支線工作中... 3 - 2025/7/16 下午 12:25:58
主線工作中... 2 - 2025/7/16 下午 12:25:59
     支線工作中... 4 - 2025/7/16 下午 12:25:59
     支線工作中... 5 - 2025/7/16 下午 12:25:59
主線工作中... 3 - 2025/7/16 下午 12:26:00
     支線工作中... 6 - 2025/7/16 下午 12:26:00
     支線工作中... 7 - 2025/7/16 下午 12:26:00
主線工作中... 4 - 2025/7/16 下午 12:26:01
     支線工作中... 8 - 2025/7/16 下午 12:26:01

以下 略
```

---

### ✅ 重點說明：

| 行為                       | 解釋                  |
| ------------------------ | ------------------- |
| `Task.Run(...)`          | 把支線計算丟到背景執行緒處理      |
| `await Task.Delay(1000)` | 主線用非同步方式等待 1 秒，不被卡住 |
| `await longRunningTask`  | 確保主線最終會等支線結束，才收工    |

---

這樣就是「**兼做兩件事，主線不卡支線，支線也不會阻塞主程式**」的實踐。如果你想再加入例外處理或時間量測也可以擴充，要我幫你加嗎？


---
## 小結論

>這跟多執行緒    比起來  不用各種委派機制   
>且 支線長時間計算   也不用宣告委派  
>也不用宣告async   就單純的函數即可
>也可以即時   改變UI  
>以上   對嗎

---

>await longRunningTask;  
>其實根本不用這一行對吧  
>反正 `HeavyCalculation()`  有能力直接更新UI


缺點：
沒辦法知道何時做完。  
若支線發生錯誤（throw Exception），你抓不到例外（會直接崩在背景）。  
結束前如果程式收掉，這個任務可能還沒做完（ex: Console 應用程式）。

情境二：你要確保支線任務完成（或抓錯誤）   
如果你想：  
等它算完再繼續（或收尾）  
確保例外能被處理（try-catch）  
UI 要等它完成再更新結果（或顯示 loading → 完成）  
那你就需要 await longRunningTask;  

